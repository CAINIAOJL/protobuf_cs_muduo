Adler-32通过求解两个16位的数值A、B实现，并将结果连结成一个32位整数.

A就是字符串中每个字节的和，而B是A在相加时每一步的阶段值之和。
在Adler-32开始运行时，A初始化为1，B初始化为0，
最后的校验和要模上65521(继216之后的最小素数)。

A = 1 + D1 + D2 + ... + Dn (mod 65521)
B = (1 + D1) + (1 + D1 + D2) + ... + (1 + D1 + D2 + ... + Dn) (mod 65521)
   = n×D1 + (n-1)×D2 + (n-2)×D3 + ... + Dn + n (mod 65521)

Adler-32(D) = B × 65536 + A
其中D为字符串的字节，n是D的字节长度

下面举例使用Adler-32校验算法产生字符串"Wikipedia"的校验和：
ASCII code          A                   B
   W: 87           1 +  87 =  88        0 +  88 =   88
   i: 105         88 + 105 = 193       88 + 193 =  281
   k: 107        193 + 107 = 300      281 + 300 =  581
   i: 105        300 + 105 = 405      581 + 405 =  986
   p: 112        405 + 112 = 517      986 + 517 = 1503
   e: 101        517 + 101 = 618     1503 + 618 = 2121
   d: 100        618 + 100 = 718     2121 + 718 = 2839
   i: 105        718 + 105 = 823     2839 + 823 = 3662
   a: 97         823 +  97 = 920     3662 + 920 = 4582
   A = 920  =  398 hex
   B = 4582 = 11E6 hex
   Output: 11E60398 hex
都默默的进行过了模65521操作了